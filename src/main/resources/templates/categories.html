<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" th:replace="~{layouts/base :: layout(~{::section})}">
  <section class="categories-page">
    <div
      class="notice"
      th:if="${categoriesMessage}"
      th:classappend="${categoriesStatus} == 'error' ? ' notice-error' : ' notice-success'">
      <span th:text="${categoriesMessage}">Categories status</span>
    </div>

    <div class="categories-toolbar">
      <form id="categories-create-parent-form" th:action="@{/categories/parents}" method="post" class="categories-hidden-form">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
        <input type="hidden" name="name" value="" />
      </form>
      <button type="button" class="button-link" id="categories-create-parent-button" th:text="#{categories.parent.createButton}">New category</button>
      <span class="subtle" th:text="#{categories.dragHint}">Drag and drop categories to reorder.</span>
    </div>

    <div class="categories-transfer">
      <div class="categories-transfer-actions">
        <a class="button-link" th:href="@{/categories/export}" th:text="#{categories.export.json}">Export categories (JSON)</a>
      </div>

      <form class="categories-import-form" th:action="@{/categories/import}" method="post" enctype="multipart/form-data">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
        <label>
          <span th:text="#{categories.import.file}">JSON file</span>
          <input type="file" name="file" accept="application/json,.json" required />
        </label>
        <button type="submit" th:text="#{categories.import.submit}">Import categories</button>
      </form>
      <p class="subtle" th:text="#{categories.import.hint}">Import adds missing parent and subcategories without deleting existing entries.</p>
    </div>

    <div
      class="categories-board"
      id="categories-board"
      th:attr="
        data-reorder-url=@{/categories/reorder},
        data-csrf-token=${_csrf.token},
        data-csrf-header=${_csrf.headerName},
        data-reorder-error=#{categories.error.reorder},
        data-prompt-new-parent=#{categories.prompt.newParent},
        data-prompt-new-sub=#{categories.prompt.newSubcategory},
        data-prompt-edit-parent=#{categories.prompt.editParent},
        data-prompt-edit-sub=#{categories.prompt.editSubcategory},
        data-confirm-delete-parent=#{confirm.deleteParentCategory},
        data-confirm-delete-sub=#{confirm.deleteSubcategory},
        data-confirm-delete-rule=#{confirm.deleteRule},
        data-rule-title-prefix=#{categories.rule.modal.titlePrefix},
        data-rule-fragments-required=#{categories.rule.error.fragmentsRequired}">

      <div class="empty-state" th:if="${#lists.isEmpty(parents)}" th:text="#{categories.empty}">No categories configured yet.</div>

      <div class="category-group" th:if="${!#lists.isEmpty(parents)}" th:each="parent : ${parents}" th:attr="data-parent-id=${parent.id}">
        <div class="category-parent-row" draggable="true">
          <span class="drag-handle" aria-hidden="true">::</span>
          <span class="category-name" th:text="${parent.name}">Essen</span>

          <div class="category-actions">
            <a
              class="category-usage-link"
              th:href="@{/transactions(parentCategoryId=${parent.id})}"
              th:title="#{categories.usage.open}"
              th:text="${parent.transactionUsageCount}">0</a>
            <span class="subtle" th:text="#{categories.usage.label}">bookings</span>

            <button
              type="button"
              class="icon-button"
              th:disabled="${parent.systemCategory}"
                th:title="#{categories.edit}"
                th:attr="data-edit-parent=${parent.id},data-current-name=${parent.name},aria-label=#{categories.edit}">
                <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 20h9" />
                  <path d="M16.5 3.5a2.12 2.12 0 1 1 3 3L7 19l-4 1 1-4Z" />
                </svg>
              </button>

            <form
              th:action="@{'/categories/parents/' + ${parent.id} + '/delete'}"
              method="post"
              th:attr="data-delete-parent-form=${parent.id}">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
                <button
                  type="submit"
                  class="icon-button"
                  th:disabled="${parent.systemCategory}"
                  th:title="#{categories.delete}"
                  th:attr="aria-label=#{categories.delete}">
                  <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M3 6h18" />
                    <path d="M8 6V4h8v2" />
                    <path d="M19 6l-1 14H6L5 6" />
                    <path d="M10 11v6" />
                    <path d="M14 11v6" />
                  </svg>
                </button>
              </form>

            <button
              type="button"
              class="button-link category-add-sub"
              th:attr="data-add-sub=${parent.id}"
              th:text="#{categories.subcategory.newButton}">New subcategory</button>
          </div>
        </div>

        <form th:action="@{'/categories/parents/' + ${parent.id}}" method="post" class="categories-hidden-form" th:attr="id=${'edit-parent-' + parent.id}">
          <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
          <input type="hidden" name="name" th:value="${parent.name}" />
        </form>

        <form th:action="@{/categories/subcategories}" method="post" class="categories-hidden-form" th:attr="id=${'create-sub-' + parent.id}">
          <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
          <input type="hidden" name="parentId" th:value="${parent.id}" />
          <input type="hidden" name="name" value="" />
        </form>

        <div class="category-sub-list" th:attr="data-sub-list=${parent.id}">
          <div class="category-sub-row" draggable="true" th:each="subcategory : ${subcategories}" th:if="${subcategory.parentId == parent.id}" th:attr="data-sub-id=${subcategory.id}">
            <span class="drag-handle" aria-hidden="true">::</span>
            <div class="category-name-wrap">
              <span class="category-name" th:text="${subcategory.name}">FastFood</span>
            </div>

            <div class="category-actions">
              <div class="category-badges">
                <a
                  class="category-usage-link"
                  th:href="@{/transactions(subcategoryId=${subcategory.id})}"
                  th:title="#{categories.usage.open}"
                  th:text="${subcategory.transactionUsageCount}">0</a>
                <span class="subtle" th:text="#{categories.usage.label}">bookings</span>
                <span class="category-chip category-chip-default" th:if="${subcategory.defaultCategory}" th:text="#{categories.badge.default}">Default</span>
                <span class="category-chip" th:if="${subcategory.systemCategory}" th:text="#{categories.badge.system}">System</span>
              </div>

              <button
                type="button"
                class="icon-button"
                th:disabled="${subcategory.systemCategory}"
                th:title="#{categories.edit}"
                th:attr="data-edit-sub=${subcategory.id},data-current-name=${subcategory.name},aria-label=#{categories.edit}">
                <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 20h9" />
                  <path d="M16.5 3.5a2.12 2.12 0 1 1 3 3L7 19l-4 1 1-4Z" />
                </svg>
              </button>

              <form
                th:action="@{'/categories/subcategories/' + ${subcategory.id} + '/delete'}"
                method="post"
                th:attr="data-delete-sub-form=${subcategory.id}">
                <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
                <button
                  type="submit"
                  class="icon-button"
                  th:disabled="${subcategory.systemCategory}"
                  th:title="#{categories.delete}"
                  th:attr="aria-label=#{categories.delete}">
                  <svg class="icon-svg" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M3 6h18" />
                    <path d="M8 6V4h8v2" />
                    <path d="M19 6l-1 14H6L5 6" />
                    <path d="M10 11v6" />
                    <path d="M14 11v6" />
                  </svg>
                </button>
              </form>

              <button
                type="button"
                class="button-link category-rule-button"
                th:classappend="${subcategory.hasRule} ? (${subcategory.ruleActive} ? ' category-rule-button-active' : ' category-rule-button-inactive') : ' category-rule-button-none'"
                th:attr="
                  data-rule-open=${subcategory.id},
                  data-rule-name=${subcategory.name},
                  data-rule-active=${subcategory.ruleActive},
                  data-rule-has-rule=${subcategory.hasRule},
                  aria-label=#{categories.rule.button}"
                th:title="${subcategory.hasRule} ? (${subcategory.ruleActive} ? #{categories.rule.status.active} : #{categories.rule.status.inactive}) : #{categories.rule.status.none}">
                <span class="category-rule-button-indicator" aria-hidden="true"></span>
                <span th:text="#{categories.rule.button}">Rule</span>
              </button>
            </div>

            <form th:action="@{'/categories/subcategories/' + ${subcategory.id}}" method="post" class="categories-hidden-form" th:attr="id=${'edit-sub-' + subcategory.id}">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <input type="hidden" name="parentId" th:value="${subcategory.parentId}" />
              <input type="hidden" name="name" th:value="${subcategory.name}" />
            </form>

            <form th:action="@{'/categories/subcategories/' + ${subcategory.id} + '/rule'}" method="post" class="categories-hidden-form" th:attr="id=${'rule-sub-' + subcategory.id}">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <input type="hidden" name="fragmentsText" value="" />
              <input type="hidden" name="active" value="false" />
            </form>

            <form th:action="@{'/categories/subcategories/' + ${subcategory.id} + '/rule/delete'}" method="post" class="categories-hidden-form" th:attr="id=${'rule-delete-sub-' + subcategory.id}">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
            </form>

            <textarea class="categories-hidden-rule-fragments" th:attr="id=${'rule-fragments-' + subcategory.id}" hidden th:text="${subcategory.ruleFragmentsText}"></textarea>
          </div>
        </div>
      </div>
    </div>

    <div class="modal-backdrop" id="categories-rule-modal" hidden>
      <div class="modal-card categories-rule-modal-card" role="dialog" aria-modal="true" aria-labelledby="categories-rule-modal-title">
        <div class="categories-rule-modal-head">
          <div class="modal-title" id="categories-rule-modal-title">Rule details</div>
          <button type="button" class="icon-button categories-rule-modal-close" id="categories-rule-close" th:attr="aria-label=#{categories.rule.modal.close}">x</button>
        </div>

        <div class="categories-rule-modal-row">
          <label class="categories-rule-toggle" for="categories-rule-active">
            <span class="categories-rule-toggle-control">
              <input type="checkbox" id="categories-rule-active" />
              <span class="categories-rule-slider" aria-hidden="true"></span>
            </span>
            <span class="categories-rule-toggle-label" th:text="#{categories.rule.modal.active}">Active</span>
          </label>
        </div>

        <label>
          <span th:text="#{categories.rule.modal.fragments}">Text fragments</span>
          <textarea id="categories-rule-fragments" rows="7"></textarea>
        </label>
        <div class="hint" th:text="#{categories.rule.modal.fragmentsHint}">One fragment per line.</div>

        <div class="categories-rule-modal-actions">
          <button type="button" class="button-link button-link-danger" id="categories-rule-delete" th:text="#{categories.rule.modal.delete}">Delete</button>
          <div class="categories-rule-modal-actions-main">
            <button type="button" class="button-link" id="categories-rule-cancel" th:text="#{categories.rule.modal.cancel}">Cancel</button>
            <button type="button" id="categories-rule-save" th:text="#{categories.rule.modal.save}">Save</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const board = document.getElementById("categories-board");
        if (!board) {
          return;
        }

        const promptNewParent = board.dataset.promptNewParent || "New category";
        const promptNewSub = board.dataset.promptNewSub || "New subcategory";
        const promptEditParent = board.dataset.promptEditParent || "Edit category";
        const promptEditSub = board.dataset.promptEditSub || "Edit subcategory";
        const reorderError = board.dataset.reorderError || "Could not reorder categories.";
        const confirmDeleteRule = board.dataset.confirmDeleteRule || "Delete this rule?";
        const ruleTitlePrefix = board.dataset.ruleTitlePrefix || "Rules for";
        const ruleFragmentsRequired = board.dataset.ruleFragmentsRequired || "Please enter at least one fragment.";
        const csrfToken = board.dataset.csrfToken;
        const csrfHeader = board.dataset.csrfHeader || "X-CSRF-TOKEN";

        const ruleModal = document.getElementById("categories-rule-modal");
        const ruleModalTitle = document.getElementById("categories-rule-modal-title");
        const ruleModalFragments = document.getElementById("categories-rule-fragments");
        const ruleModalActive = document.getElementById("categories-rule-active");
        const ruleModalDelete = document.getElementById("categories-rule-delete");
        const ruleModalSave = document.getElementById("categories-rule-save");
        const ruleModalCancel = document.getElementById("categories-rule-cancel");
        const ruleModalClose = document.getElementById("categories-rule-close");
        let selectedRuleSubId = null;

        const closeRuleModal = () => {
          if (!ruleModal) {
            return;
          }
          ruleModal.setAttribute("hidden", "hidden");
          selectedRuleSubId = null;
        };

        const openRuleModal = (button) => {
          if (!ruleModal || !ruleModalFragments || !ruleModalActive || !ruleModalTitle) {
            return;
          }
          const subId = button.getAttribute("data-rule-open");
          if (!subId) {
            return;
          }

          selectedRuleSubId = subId;
          const subName = button.getAttribute("data-rule-name") || "";
          const hasRule = button.getAttribute("data-rule-has-rule") === "true";
          const isActive = button.getAttribute("data-rule-active") === "true";
          const fragments = document.getElementById("rule-fragments-" + subId);

          ruleModalTitle.textContent = ruleTitlePrefix + " " + subName;
          ruleModalActive.checked = hasRule ? isActive : true;
          ruleModalFragments.value = fragments ? fragments.value : "";

          if (ruleModalDelete) {
            ruleModalDelete.disabled = !hasRule;
          }

          ruleModal.removeAttribute("hidden");
          ruleModalFragments.focus();
        };

        if (ruleModal) {
          ruleModal.addEventListener("click", (event) => {
            if (event.target === ruleModal) {
              closeRuleModal();
            }
          });
        }
        if (ruleModalCancel) {
          ruleModalCancel.addEventListener("click", () => {
            closeRuleModal();
          });
        }
        if (ruleModalClose) {
          ruleModalClose.addEventListener("click", () => {
            closeRuleModal();
          });
        }

        board.querySelectorAll("[data-rule-open]").forEach((button) => {
          button.addEventListener("click", () => {
            openRuleModal(button);
          });
        });

        if (ruleModalSave) {
          ruleModalSave.addEventListener("click", () => {
            if (!selectedRuleSubId || !ruleModalFragments || !ruleModalActive) {
              return;
            }
            const normalized = ruleModalFragments.value.trim();
            if (!normalized) {
              window.alert(ruleFragmentsRequired);
              return;
            }
            const form = document.getElementById("rule-sub-" + selectedRuleSubId);
            if (!form) {
              return;
            }
            const fragmentsInput = form.querySelector("input[name='fragmentsText']");
            const activeInput = form.querySelector("input[name='active']");
            if (!fragmentsInput || !activeInput) {
              return;
            }
            fragmentsInput.value = ruleModalFragments.value;
            activeInput.value = ruleModalActive.checked ? "true" : "false";
            form.submit();
          });
        }

        if (ruleModalDelete) {
          ruleModalDelete.addEventListener("click", () => {
            if (!selectedRuleSubId || ruleModalDelete.disabled) {
              return;
            }
            if (!window.confirm(confirmDeleteRule)) {
              return;
            }
            const form = document.getElementById("rule-delete-sub-" + selectedRuleSubId);
            if (!form) {
              return;
            }
            form.submit();
          });
        }

        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && ruleModal && !ruleModal.hasAttribute("hidden")) {
            closeRuleModal();
          }
        });

        const createParentButton = document.getElementById("categories-create-parent-button");
        const createParentForm = document.getElementById("categories-create-parent-form");
        if (createParentButton && createParentForm) {
          createParentButton.addEventListener("click", () => {
            const value = window.prompt(promptNewParent, "");
            if (value == null) {
              return;
            }
            const normalized = value.trim();
            if (!normalized) {
              return;
            }
            createParentForm.querySelector("input[name='name']").value = normalized;
            createParentForm.submit();
          });
        }

        board.querySelectorAll("[data-add-sub]").forEach((button) => {
          button.addEventListener("click", () => {
            const parentId = button.getAttribute("data-add-sub");
            if (!parentId) {
              return;
            }
            const value = window.prompt(promptNewSub, "");
            if (value == null) {
              return;
            }
            const normalized = value.trim();
            if (!normalized) {
              return;
            }
            const form = document.getElementById("create-sub-" + parentId);
            if (!form) {
              return;
            }
            form.querySelector("input[name='name']").value = normalized;
            form.submit();
          });
        });

        board.querySelectorAll("[data-edit-parent]").forEach((button) => {
          button.addEventListener("click", () => {
            const parentId = button.getAttribute("data-edit-parent");
            if (!parentId) {
              return;
            }
            const currentName = button.getAttribute("data-current-name") || "";
            const value = window.prompt(promptEditParent, currentName);
            if (value == null) {
              return;
            }
            const normalized = value.trim();
            if (!normalized) {
              return;
            }
            const form = document.getElementById("edit-parent-" + parentId);
            if (!form) {
              return;
            }
            form.querySelector("input[name='name']").value = normalized;
            form.submit();
          });
        });

        board.querySelectorAll("[data-edit-sub]").forEach((button) => {
          button.addEventListener("click", () => {
            const subId = button.getAttribute("data-edit-sub");
            if (!subId) {
              return;
            }
            const currentName = button.getAttribute("data-current-name") || "";
            const value = window.prompt(promptEditSub, currentName);
            if (value == null) {
              return;
            }
            const normalized = value.trim();
            if (!normalized) {
              return;
            }
            const form = document.getElementById("edit-sub-" + subId);
            if (!form) {
              return;
            }
            form.querySelector("input[name='name']").value = normalized;
            form.submit();
          });
        });

        board.querySelectorAll("[data-delete-parent-form]").forEach((form) => {
          form.addEventListener("submit", (event) => {
            const ok = window.confirm(board.dataset.confirmDeleteParent || "Delete category?");
            if (!ok) {
              event.preventDefault();
            }
          });
        });

        board.querySelectorAll("[data-delete-sub-form]").forEach((form) => {
          form.addEventListener("submit", (event) => {
            const ok = window.confirm(board.dataset.confirmDeleteSub || "Delete subcategory?");
            if (!ok) {
              event.preventDefault();
            }
          });
        });

        let dragMode = null;
        let draggedGroup = null;
        let draggedSub = null;

        const groups = () => Array.from(board.querySelectorAll(".category-group"));

        const parentRows = () => Array.from(board.querySelectorAll(".category-parent-row"));
        parentRows().forEach((row) => {
          row.addEventListener("dragstart", (event) => {
            dragMode = "parent";
            draggedGroup = row.closest(".category-group");
            if (!draggedGroup) {
              dragMode = null;
              return;
            }
            draggedGroup.classList.add("is-dragging-parent");
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = "move";
            }
          });

          row.addEventListener("dragend", async () => {
            if (dragMode === "parent") {
              await persistReorder();
            }
            if (draggedGroup) {
              draggedGroup.classList.remove("is-dragging-parent");
            }
            dragMode = null;
            draggedGroup = null;
          });
        });

        board.addEventListener("dragover", (event) => {
          if (dragMode !== "parent" || !draggedGroup) {
            return;
          }
          event.preventDefault();
          const ordered = groups().filter((group) => group !== draggedGroup);
          let insertBefore = null;
          let closest = Number.NEGATIVE_INFINITY;

          for (const group of ordered) {
            const rect = group.getBoundingClientRect();
            const offset = event.clientY - rect.top - rect.height / 2;
            if (offset < 0 && offset > closest) {
              closest = offset;
              insertBefore = group;
            }
          }

          if (insertBefore) {
            board.insertBefore(draggedGroup, insertBefore);
          } else {
            board.appendChild(draggedGroup);
          }
        });

        const subLists = () => Array.from(board.querySelectorAll(".category-sub-list"));
        const subRows = () => Array.from(board.querySelectorAll(".category-sub-row"));

        const findSubInsertTarget = (container, y, movingRow) => {
          const candidates = Array.from(container.querySelectorAll(".category-sub-row")).filter((row) => row !== movingRow);
          let insertBefore = null;
          let closest = Number.NEGATIVE_INFINITY;
          for (const row of candidates) {
            const rect = row.getBoundingClientRect();
            const offset = y - rect.top - rect.height / 2;
            if (offset < 0 && offset > closest) {
              closest = offset;
              insertBefore = row;
            }
          }
          return insertBefore;
        };

        subRows().forEach((row) => {
          row.addEventListener("dragstart", (event) => {
            dragMode = "sub";
            draggedSub = row;
            row.classList.add("is-dragging-sub");
            if (event.dataTransfer) {
              event.dataTransfer.effectAllowed = "move";
            }
          });

          row.addEventListener("dragend", async () => {
            if (dragMode === "sub") {
              await persistReorder();
            }
            row.classList.remove("is-dragging-sub");
            dragMode = null;
            draggedSub = null;
          });
        });

        subLists().forEach((list) => {
          list.addEventListener("dragover", (event) => {
            if (dragMode !== "sub" || !draggedSub) {
              return;
            }
            event.preventDefault();
            const target = findSubInsertTarget(list, event.clientY, draggedSub);
            if (target) {
              list.insertBefore(draggedSub, target);
            } else {
              list.appendChild(draggedSub);
            }
          });
        });

        const updateEditFormsParent = () => {
          groups().forEach((group) => {
            const parentId = group.getAttribute("data-parent-id");
            if (!parentId) {
              return;
            }
            group.querySelectorAll(".category-sub-row").forEach((row) => {
              const subId = row.getAttribute("data-sub-id");
              if (!subId) {
                return;
              }
              const form = document.getElementById("edit-sub-" + subId);
              if (!form) {
                return;
              }
              const parentInput = form.querySelector("input[name='parentId']");
              if (parentInput) {
                parentInput.value = parentId;
              }
            });
          });
        };

        const buildReorderPayload = () => {
          const parentsPayload = groups().map((group) => {
            const parentId = Number(group.getAttribute("data-parent-id"));
            const subcategoryIds = Array.from(group.querySelectorAll(".category-sub-row"))
                .map((row) => Number(row.getAttribute("data-sub-id")));
            return {
              parentId,
              subcategoryIds,
            };
          });
          return { parents: parentsPayload };
        };

        const persistReorder = async () => {
          if (!csrfToken) {
            return;
          }
          updateEditFormsParent();
          const payload = buildReorderPayload();
          try {
            const response = await fetch(board.dataset.reorderUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                [csrfHeader]: csrfToken,
              },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              window.alert(reorderError);
              window.location.reload();
            }
          } catch (error) {
            window.alert(reorderError);
            window.location.reload();
          }
        };
      })();
    </script>
  </section>
</html>
