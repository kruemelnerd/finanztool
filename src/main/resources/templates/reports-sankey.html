<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" th:replace="~{layouts/base :: layout(~{::section})}">
  <section class="sankey-report">
    <div class="sankey-toolbar">
      <form method="get" th:action="@{/reports/sankey}">
        <label>
          <span th:text="#{sankey.year}">Year</span>
          <select name="year" onchange="this.form.submit()">
            <option
              th:each="yearOption : ${yearOptions}"
              th:value="${yearOption}"
              th:selected="${yearOption == selectedYear}"
              th:text="${yearOption}">2025</option>
          </select>
        </label>
      </form>
    </div>

    <div
      id="sankey-root"
      class="sankey-shell"
      th:attr="data-year=${selectedYear},data-center-label=#{sankey.source.center},data-income-label=#{sankey.source.income},data-expense-label=#{sankey.source.expense},data-other-income-label=#{sankey.other.income},data-other-expense-label=#{sankey.other.expense}">
      <div id="sankey-chart" role="img" aria-label="Sankey chart"></div>
      <p id="sankey-empty" class="empty-state" th:text="#{sankey.empty}">No data for selected year.</p>
    </div>

    <script src="https://www.gstatic.com/charts/loader.js"></script>

    <script>
      (() => {
        const root = document.getElementById("sankey-root");
        const chartElement = document.getElementById("sankey-chart");
        const emptyState = document.getElementById("sankey-empty");
        if (!root || !chartElement || !emptyState || !window.google || !window.google.charts) {
          return;
        }

        const selectedYear = root.dataset.year;
        const centerLabel = root.dataset.centerLabel || "Center";
        const incomeLabel = root.dataset.incomeLabel || "Income";
        const expenseLabel = root.dataset.expenseLabel || "Expense";
        const otherIncomeLabel = root.dataset.otherIncomeLabel || "Other income";
        const otherExpenseLabel = root.dataset.otherExpenseLabel || "Other expenses";

        const MAX_NODES_PER_SIDE = 8;
        const MIN_CHART_HEIGHT = 340;
        const MAX_CHART_HEIGHT = 620;

        const isIncomeNode = (nodeId) => typeof nodeId === "string" && nodeId.startsWith("income-cat-");
        const isExpenseNode = (nodeId) => typeof nodeId === "string" && nodeId.startsWith("expense-cat-");
        const asNumber = (value) => {
          const numeric = Number(value);
          return Number.isFinite(numeric) ? numeric : 0;
        };

        const showEmptyState = () => {
          chartElement.style.display = "none";
          emptyState.style.display = "block";
        };

        const showChart = () => {
          chartElement.style.display = "block";
          emptyState.style.display = "none";
        };

        const loadCharts = () =>
          new Promise((resolve, reject) => {
            window.google.charts.load("current", { packages: ["sankey"] });
            window.google.charts.setOnLoadCallback(() => {
              if (!window.google.visualization || typeof window.google.visualization.Sankey !== "function") {
                reject(new Error("Google Sankey package unavailable"));
                return;
              }
              resolve();
            });
          });

        const fetchData = () =>
          fetch(`/api/reports/sankey?year=${encodeURIComponent(selectedYear)}`, {
            headers: {
              Accept: "application/json"
            }
          }).then((response) => {
            if (!response.ok) {
              throw new Error(`Sankey request failed with status ${response.status}`);
            }
            return response.json();
          });

        const sumEntries = (entries) => entries.reduce((sum, entry) => sum + entry.cents, 0);

        const compactTopEntries = (entries, otherLabel, otherIdPrefix) => {
          if (entries.length <= MAX_NODES_PER_SIDE) {
            return entries;
          }

          const visibleLimit = Math.max(1, MAX_NODES_PER_SIDE - 1);
          const visible = entries.slice(0, visibleLimit);
          const hidden = entries.slice(visibleLimit);
          const hiddenCents = sumEntries(hidden);
          if (hiddenCents > 0) {
            visible.push({
              id: `${otherIdPrefix}-other`,
              label: otherLabel,
              cents: hiddenCents
            });
          }
          return visible;
        };

        const makeDisplayLabelsUnique = (incomeEntries, expenseEntries) => {
          const totalLabels = new Map();
          [...incomeEntries, ...expenseEntries].forEach((entry) => {
            totalLabels.set(entry.label, (totalLabels.get(entry.label) || 0) + 1);
          });

          const sideLabelCounter = new Map();
          const decorate = (entries, sideLabel) =>
            entries.map((entry) => {
              if ((totalLabels.get(entry.label) || 0) <= 1) {
                return entry;
              }

              const counterKey = `${sideLabel}:${entry.label}`;
              const counter = (sideLabelCounter.get(counterKey) || 0) + 1;
              sideLabelCounter.set(counterKey, counter);
              const suffix = counter === 1 ? sideLabel : `${sideLabel} ${counter}`;
              return {
                ...entry,
                label: `${entry.label} (${suffix})`
              };
            });

          return {
            income: decorate(incomeEntries, incomeLabel),
            expense: decorate(expenseEntries, expenseLabel)
          };
        };

        const buildRows = (report) => {
          const links = Array.isArray(report.links) ? report.links : [];
          const nodes = Array.isArray(report.nodes) ? report.nodes : [];
          const nodeLabels = new Map(nodes.map((node) => [node.id, node.label || node.id]));
          const incomeTotals = new Map();
          const expenseTotals = new Map();

          links.forEach((link) => {
            const cents = asNumber(link.valueCents);
            if (cents <= 0) {
              return;
            }

            if (isIncomeNode(link.source) && link.target === "center") {
              incomeTotals.set(link.source, (incomeTotals.get(link.source) || 0) + cents);
              return;
            }

            if (link.source === "center" && isExpenseNode(link.target)) {
              expenseTotals.set(link.target, (expenseTotals.get(link.target) || 0) + cents);
            }
          });

          const incomeEntries = Array.from(incomeTotals.entries())
            .map(([id, cents]) => ({
              id,
              label: nodeLabels.get(id) || incomeLabel,
              cents
            }))
            .sort((left, right) => right.cents - left.cents);

          const expenseEntries = Array.from(expenseTotals.entries())
            .map(([id, cents]) => ({
              id,
              label: nodeLabels.get(id) || expenseLabel,
              cents
            }))
            .sort((left, right) => right.cents - left.cents);

          const compactIncomeEntries = compactTopEntries(incomeEntries, otherIncomeLabel, "income");
          const compactExpenseEntries = compactTopEntries(expenseEntries, otherExpenseLabel, "expense");
          const uniqueLabels = makeDisplayLabelsUnique(compactIncomeEntries, compactExpenseEntries);

          const rows = [];
          uniqueLabels.income.forEach((entry) => {
            rows.push([entry.label, centerLabel, entry.cents / 100]);
          });
          uniqueLabels.expense.forEach((entry) => {
            rows.push([centerLabel, entry.label, entry.cents / 100]);
          });

          return {
            rows,
            maxColumnSize: Math.max(compactIncomeEntries.length, compactExpenseEntries.length, 1)
          };
        };

        const calculateChartHeight = (maxColumnSize) => {
          const compactLayout = window.innerWidth < 960;
          const viewportHeight = Math.round((window.innerHeight || 860) * (compactLayout ? 0.56 : 0.64));
          const rowsBasedHeight = compactLayout
            ? 190 + maxColumnSize * 34
            : 210 + maxColumnSize * 38;
          return Math.max(MIN_CHART_HEIGHT, Math.min(MAX_CHART_HEIGHT, Math.max(viewportHeight, rowsBasedHeight)));
        };

        const colorOptions = () => {
          const dark = document.documentElement.dataset.theme === "dark";
          if (dark) {
            return {
              labelColor: "#e2e8f0",
              nodeColors: ["#22d3ee", "#2dd4bf", "#84cc16", "#38bdf8", "#f59e0b", "#fb7185", "#a78bfa", "#f97316"],
              linkColors: ["#22d3ee", "#e2e8f0", "#fb923c"]
            };
          }
          return {
            labelColor: "#1f2937",
            nodeColors: ["#0f766e", "#16a34a", "#0ea5e9", "#0284c7", "#f97316", "#ef4444", "#7c3aed", "#d97706"],
            linkColors: ["#0f766e", "#1e40af", "#ea580c"]
          };
        };

        const drawChart = (dataset) => {
          const chartHeight = calculateChartHeight(dataset.maxColumnSize);
          const colors = colorOptions();

          chartElement.style.height = `${chartHeight}px`;

          const dataTable = new window.google.visualization.DataTable();
          dataTable.addColumn("string", "From");
          dataTable.addColumn("string", "To");
          dataTable.addColumn("number", "Amount");
          dataTable.addRows(dataset.rows);

          const chart = new window.google.visualization.Sankey(chartElement);
          chart.draw(dataTable, {
            height: chartHeight,
            backgroundColor: "transparent",
            tooltip: {
              textStyle: {
                fontName: "Sora",
                fontSize: 12
              }
            },
            sankey: {
              iterations: 64,
              node: {
                width: 18,
                nodePadding: window.innerWidth < 960 ? 16 : 20,
                colors: colors.nodeColors,
                label: {
                  fontName: "Sora",
                  fontSize: window.innerWidth < 960 ? 12 : 13,
                  color: colors.labelColor,
                  bold: true
                }
              },
              link: {
                colorMode: "gradient",
                colors: colors.linkColors
              }
            }
          });
        };

        let latestDataset = null;
        let resizeTimer = null;

        const redraw = () => {
          if (!latestDataset) {
            return;
          }
          drawChart(latestDataset);
        };

        window.addEventListener("resize", () => {
          if (!latestDataset) {
            return;
          }
          window.clearTimeout(resizeTimer);
          resizeTimer = window.setTimeout(redraw, 140);
        });

        const themeObserver = new MutationObserver((changes) => {
          if (!latestDataset) {
            return;
          }
          const themeChanged = changes.some((change) => change.attributeName === "data-theme");
          if (themeChanged) {
            redraw();
          }
        });
        themeObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["data-theme"] });

        Promise.all([loadCharts(), fetchData()])
          .then(([, report]) => {
            const dataset = buildRows(report);
            if (dataset.rows.length === 0) {
              showEmptyState();
              return;
            }

            latestDataset = dataset;
            showChart();
            drawChart(dataset);
          })
          .catch(() => {
            showEmptyState();
          });
      })();
    </script>
  </section>
</html>
